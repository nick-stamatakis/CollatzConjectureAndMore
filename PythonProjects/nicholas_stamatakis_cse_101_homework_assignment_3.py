# -*- coding: utf-8 -*-
"""Nicholas Stamatakis CSE 101 Homework Assignment #3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-v11OsOOTF8UGaQ5T051siTpjYIWxzT7

# CSE 101: Computer Science Principles

#### Stony Brook University, Summer 2021, Session I Extended

## Homework Assignment #3

#### Due: Sunday, June 13, 2021 at 11:59 pm EDT

#### Learning Outcomes
By the end of these exercises you should be able to:
* Solve problems using basic operators, functions and methods for strings.
* Design and implement algorithms that use for-loops to perform mathematical calculations.
* Design and implement algorithms that use iteration to process strings.

### Part 1: Beware of Evil E (8 points)

The letter `E` in a string is considered evil, and it will remove the letters immediately adjacent it and replace each with a space.

For example, the string `hEllo` will become ` E lo`. `ELlo` will become `E lo`

Complete the function `evil_e`, which takes in a string `message` that contains at most one one `E`. Return the string after the evil `E` takes its effect on the neighboring letters. If the string contains no `E`, the function returns the input string unchanged. 

Note: this function is case-sensitive! Only capital letter `E` is evil.

Examples:

Function Call | Return Value
:-- | :--
`evil_e('SEAWOLF')` | `' E WOLF'`
`evil_e('Seawolf')` | `'Seawolf'`
`evil_e('UNIVERSITY')` | `'UNI E SITY'`
`evil_e('Stony Brook')` | `'Stony Brook'`
`evil_e('COMPUTE')` | `'COMPU E'`
`evil_e('COMPUTER')` | `'COMPU E '`
`evil_e('Seawolf')` | `'Seawolf'`
`evil_e('EARTH')` | `'E RTH'`
"""

def evil_e(message):
    if 'E' in message:
        indexE=message.find('E')
        prec_E=message[indexE-1:indexE]
        after_E=message[indexE+1:indexE+2]
        rem_prec_E=message[:indexE-1]
        rem_after_E=message[indexE+2:]
        if indexE == 0:
            new_message = "E " + str(rem_after_E)
            return new_message
        elif indexE == len(message)-1:
            new_message = str(rem_prec_E) + " E"
            return new_message
        else:
            new_message= str(rem_prec_E) + " E " + str(rem_after_E)
            return new_message
        print(new_message)
    else:
        return message

# Test cases
print(evil_e('SEAWOLF'))
print(evil_e('Seawolf'))
print(evil_e('UNIVERSITY'))
print(evil_e('Stony Brook'))
print(evil_e('COMPUTE'))
print(evil_e('COMPUTER'))
print(evil_e('Seawolf'))
print(evil_e('EARTH'))

"""### Part 2: Rickster Encryption (8 points)

For this part and the next you will be implementing the obscure "Rickster" encryption and decryption algorithms, respectively. The encryption scheme is simple, and you will have to write a function that encrypts only one word. This word is called the **plaintext**. The algorithm for encryption goes like this:

1. Split up the word into three components: front, middle, and end. The middle is just the middle letter of the word. (Hint: use `//` in any divisions you perform.) The front is all the characters to the left of the middle letter, and the end is all the characters after the middle letter. (Use string slicing!)

1. To construct the encrypted word, shift the front component to where the middle component is, shift the middle component to where the end component belongs, and finally, shift the end component to where the front component belongs.

1. Next, reverse the front and end components of the plaintext. (In the lecture notes you will find the code for how to reverse a string.)

1. Concatenate the three components together in the right order to generate the encrypted word, which is called the **ciphertext**.

You may assume that every plaintext string contains at least 3 characters.

Suppose the following is the plaintext: `Front` `Middle` `End`

The ciphertext will be: `Reversed End` `Reversed Front` `Middle`

Complete the function `rickster_encrypt`, which takes a plaintext string, encrypts it according to the above algorithm, and returns the ciphertext.

Examples:

Function Call | Return Value
:-- | :--
`rickster_encrypt('ABCDEFGHIJKLMN')` | `'NMLKJIGFEDCBAH'`
`rickster_encrypt('ABC')` | `'CAB'`
`rickster_encrypt('Programming')` | `'gnimmrgorPa'`
`rickster_encrypt('ABCDE')` | `'EDBAC'`
`rickster_encrypt('ABCDEFGH')` | `'HGFDCBAE'`
"""

def rickster_encrypt(plaintext):
    mid_index=len(plaintext)//2
    mid = plaintext[mid_index]
    front = plaintext[:mid_index]
    end = plaintext[mid_index+1:]

    temp_str = end + front + mid
    front=front[::-1]
    end=end[::-1]
    ciphertext = end + front + mid
    return ciphertext

# Test cases
print(rickster_encrypt('ABCDEFGHIJKLMN'))
print(rickster_encrypt('ABC'))
print(rickster_encrypt('Programming'))
print(rickster_encrypt('ABCDE'))
print(rickster_encrypt('ABCDEFGH'))

"""### Part 3: Rickster Decryption (8 points)

In this part you will implement the decryption algorithm for the Rickter encryption algorithm. It essentially undoes the encryption process explained in the previous part of the assignment:

1. You can recover the middle letter of the original plaintext easily since it is the final character of the ciphertext. 

1. You have to retrieve the front and end components of the ciphertext and then reverse both. However, since a string can be even or odd in length, the front and end components might not always have the same number of letters.

 * We know that the end component starts from the beginning of the ciphertext, but how many characters should the **end** have? If the string is even in length, then it should have `length // 2 - 1` number of letters. If the string is odd in length, then both front and end component have `length // 2` number of letters. So, you need to use an if-statement to determine whether the string has even length or odd length. Some examples to make this clearer are given below.

1. After grabbing the front, end, and middle components, you have to reverse front and end and put them back together.

**Example #1.** Consider the ciphertext `EDBAC`. This has an odd length (5). `C` must have been the original middle character. So we can split `ED` and `BA` from the ciphertext, reverse them, and then concatenate all three parts in the correct order to generate `ABCDE`. Note that we extracted **2** characters for each of the front and end, because that 5 divided by 2 equals **2** (assuming integer division). We see that the quotient of the division tells us how many characters to extract.

**Example #2.** Consider the ciphertext `HGFDCBAE`. This has even length (8). `E` must have been the original "middle" character. Take the length, 8, divide by 2 and subtract 1 to get **3**. The reversed end of the original string is the first **3** characters of the ciphertext (`HGF`). The reversed front of the original string is the next 4 (8 // 2) characters of the ciphertext (`DCBA`). We reverse the front and end, and concatenate them with the `E` in the right order to generate `ABCDEFGH`, which is the original ciphertext.

Complete the function `rickster_encrypt`, which takes a plaintext string, encrypts it according to the above algorithm, and returned the ciphertext.

Examples:

Function Call | Return Value
:-- | :--
`rickster_decrypt('NMLKJIGFEDCBAH')` | `'ABCDEFGHIJKLMN'`
`rickster_decrypt('CAB')` | `'ABC'`
`rickster_decrypt('gnimmrgorPa')` | `'Programming'`
`rickster_decrypt('EDBAC')` | `'ABCDE'`
`rickster_decrypt('HGFDCBAE')` | `'ABCDEFGH'`
"""

def rickster_decrypt(ciphertext):
    mid = ciphertext[-1]
    mid_index=len(ciphertext) // 2
    end=ciphertext[0:mid_index]
    front=ciphertext[mid_index:-1]
    end=end[::-1]
    front=front[::-1]
    plaintext = front + mid + end
    return plaintext
# Test cases
print(rickster_decrypt('NMLKJIGFEDCBAH'))
print(rickster_decrypt('CAB'))
print(rickster_decrypt('gnimmrgorPa'))
print(rickster_decrypt('EDBAC'))
print(rickster_decrypt('HGFDCBAE'))

# I did not use an if statement because I saw that if I did it this way I was still able to get the
# same outputs.

"""### Part 4: Evaluate $\sum_{k=1}^{n} \frac{x^k}{k} \left(x^2 + k^2 \right)$ (8 points)

Complete the function `calculate`, which computes and returns the value of the following sum for the given arguments, `x` and `n`.

$$\sum_{k=1}^{n} \frac{x^k}{k} \left(x^2 + k^2 \right) = \frac{x^1}{1} \left( x^2 + 1^2 \right) + \frac{x^2}{2} \left( x^2 + 2^2 \right) + \cdots + \frac{x^n}{n} \left( x^2 + n^2 \right) $$

Assume $n \ge 1$.

Examples:

Function Call | Return Value
:-- | :--
`calculate(5, 4)` | `8315.41666666666`
`calculate(2, 4)` | `140.66666666666666`
`calculate(-5, 6)` | `132826.25`

"""

def calculate(x, n):
    sum = 0
    for k in range(1,n+1):
        sum += (x**k / k) * (x**2 + k**2)
    return sum
    

# Test cases
print(calculate(5, 4))
print(calculate(2, 4))
print(calculate(-5, 6))

"""### Part 5: Password Strength Calculator (8 points)

Have you ever had the experience, while creating an account on a website, that a little meter pops up to tell you how "strong" your password is? Let's create our own version of that meter. Complete the function `password_strength`, that takes one argument, `password`, which is a string of characters consisting of lowercase letters, uppercase letters, digits and non-alphanumerical symbols. The function allocates points to `password` based on the location of certain characters in the string. The total at the end is a "score" that measures how strong the password is.

Remember that you can use `int()` to convert a digit character into actual integer value.

Rule | Points to Add
:-- | :--
the leftmost character is a symbol (!, @, #, $) | +40
the leftmost character is a digit | +30
an even digit anywhere but the leftmost position | +20 for each such digit
an odd digit anywhere but the leftmost position | +25 for each such digit
a lowercase letter anywhere | +5 for each such lowercase letter
the last character is a lowercase letter | +15 

Examples:

Function Call | Return Value
:-- | :--
`password_strength('!Foo')` | `65`
`password_strength('@#Okayz')` | `75`
`password_strength('bGWp')` | `25`
`password_strength('OOOOOO121k')` | `90`
`password_strength('!123321strongpassword')` | `265`
`password_strength('9hehe@')` | `50`
`password_strength('$securedpassword')` | `130`
`password_strength('.exestrongpassword')` | `100`
`password_strength('1 == 1')` | `55`
`password_strength('2345678')` | `165`
"""

def password_strength(password):
    points=0
    first = password[0]
    if password[0] == "!" or password[0] =="@" or password[0] =="#" or password[0] =="$":
        points += 40
    if password[0].isdigit():
        points += 30
    for ch in password[1:]:
        if ch.isdigit():
            ch = int(ch)
            if ch % 2 == 0:
                points += 20
            if ch % 2 == 1:
                points += 25
    for ch in password:
        if ch.islower():
            points += 5
    if password[-1].islower():
        points += 15
    return points


print(password_strength('!Foo'))
print(password_strength('@#Okayz'))
print(password_strength('bGWp'))
print(password_strength('OOOOOO121k'))
print(password_strength('!123321strongpassword'))
print(password_strength('9hehe@'))
print(password_strength('$securedpassword'))
print(password_strength('.exestrongpassword'))
print(password_strength('1 == 1'))
print(password_strength('2345678'))

"""### How to Submit Your Work

1. Go to the [course website](https://sites.google.com/stonybrook.edu/cse101sum/schedule-session-i).

1. Click the **Submit** link for this assignment.

1. Type your Net ID (Blackboard login) on the line provided.

1. Press the button marked **Add file**.

1. Click the **My Drive** tab.

1. Click on the file you wish to submit.

1. Hit **Select**.

1. Hit **Submit** to submit your file grading.
"""